%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LATEX-TEMPLATE TECHNISCH RAPPORT
%-------------------------------------------------------------------------------
% Voor informatie over het technisch rapport, zie
% http://practicumav.nl/onderzoeken/rapport.html
% Voor readme en meest recente versie van het template, zie
% https://gitlab-fnwi.uva.nl/informatica/LaTeX-template.git
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-------------------------------------------------------------------------------
%	PACKAGES EN DOCUMENT CONFIGURATIE
%-------------------------------------------------------------------------------

\documentclass{uva-inf-article}
\usepackage[english]{babel}

\usepackage[
backend=biber,
style=numeric,
citestyle=numeric 
]{biblatex}

\usepackage{xcolor}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{listings}
\newcommand\todo[1]{\textcolor{red}{#1}}


\lstdefinestyle{mystyle}{
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\addbibresource{citations.bib}

%-------------------------------------------------------------------------------
%	GEGEVENS VOOR IN DE TITEL
%-------------------------------------------------------------------------------

% Vul de naam van de opdracht in.
\assignment{Software Evolution Series 2}
% Vul het soort opdracht in.
\assignmenttype{Report}
% Vul de titel van de eindopdracht in.
\title{Report}

% Vul de volledige namen van alle auteurs in.
\authors{Cornelius Ries; Piotr Kosytorz}
% Vul de corresponderende UvAnetID's in.
\uvanetids{11884827; 11876964}

% Vul altijd de naam in van diegene die het nakijkt, tutor of docent.
\tutor{Riemer van Rozen}
% Vul eventueel ook de naam van de docent of vakcoordinator toe.
\docent{}
% Vul hier de naam van de PAV-groep  in.
% \group{Group 7}
% Vul de naam van de cursus in.
\course{Software Evolution}
% Te vinden op onder andere Datanose.
\courseid{}

% Dit is de datum die op het document komt te staan. Standaard is dat vandaag.
\date{\today}

%-------------------------------------------------------------------------------
%	VOORPAGINA
%-------------------------------------------------------------------------------

\begin{document}
\maketitle

%-------------------------------------------------------------------------------
%	INHOUDSOPGAVE EN ABSTRACT
%-------------------------------------------------------------------------------

% Niet doen bij korte verslagen en rapporten
%\tableofcontents
%\begin{abstract}
%\lipsum[13]
%\end{abstract}

%-------------------------------------------------------------------------------
%	INTRODUCTIE
%-------------------------------------------------------------------------------

\section{Introduction}

This documents contains our notes and answers to the questions about software metrics (practical lab Series 2).

\todo{Rewrite the introduction}

\section{Definitions}

\todo {
	\begin{itemize}
		\item{Clone (reference to kamiya2002ccfinder)}
		\item{Clone class (reference to kamiya2002ccfinder)}
		\item{The biggest clone }
		\item{The biggest clone class}
	\end{itemize}
}

In order to provide a tool to satisfy the assignment's objectives, a good understanding of the key concepts used in clone detection is needed. Based on a biref literature study, we have selected the following definitions as the base for our work and evaluation of the cloning problem:

\begin{itemize}
	\item{\textbf{Clone relation} is an equivalence relation on code portions \cite{kamiya2002ccfinder}.}
	\item{\textbf{Clone pair} is a set of two code portions that are in clone relation with each other (compare \cite{kamiya2002ccfinder}).}
	\item{\textbf{Clone class} is an equivalence class of clonerelation. In other words, it is a set of multiple (more than one) code portions which hold mutual clone relation to each other (compare \cite{kamiya2002ccfinder}).}
\end{itemize}	

\subsection{Clone type-1}
Per definition from \cite{koschke2008identifying} type 1 clones are strict textual clones, excluding comments and whitespaces.

\subsection{Clone type-2}
Per definition from \cite{koschke2008identifying} type 2 clones are "a syntactically identical copy; only variable, type, or function identifiers have been changed".

\subsection{Clone type-3}
Per definition from \cite{koschke2008identifying} type 3 clones are copies with further changes like adding/removing statements.

\section{Algorithm design}

\todo {
	\begin{itemize}
		\item{General algorithm design (sketch: text description) }
		\item{Type-3 clean method (pseudocode) / We dont have it yet }
		\item{Formalised algorithm (pseudocode with references to type-1, type-2 clean methods)}
		\item{Describe how the algorithm is covered in the literature (and provide references).}
	\end{itemize}
}

\subsection{General algorithm design}

The idea and algorithm of our duplication detection is based on the
information from \cite{lazar2014clone} and \cite{baxter1998clone}. 
The main idea behind this approach is to use the abstract syntax tree for clone detection.
After creating the ast from the source files,  the nodes are hashed into different buckets.
If a bucket has more than one element, it follows, that there are multiple locations in the source code of this node.
This counts as one clone class. There are multiple types of clones that our tool can detect.
These are type 1 and type 2 clones.

\subsection{Type-1 cleaning}

If using the AST approach, the bucket key is in general just the node itself. With rascal though, there was a change in the implementation
that shifted the \texttt{loc} and other informations of a node from the annotations on the node, to information contained in the node.
This messed up the matching because every location was unique, which resulted in every node (because of subnodes) being unique. 
To circumvante the problem we remove the unnessecary information from all the relevant nodes. The actual cleaning \texttt{cleanNode} is done
by visiting all the subnodes of a relevant node and replacing the node with a cleaned version of the original node using the \texttt{insert} statement.

\subsection{Type-2 cleaning}

For type 2 detection we also use the AST. To streamline all the information that is contained in the node we visit all the subnodes of a node
and replace specific variables/identifiers/types with a general one. The replacement is done using the rascal \texttt{visit - case => } notation.

\begin{lstlisting}[language=Java, style=mystyle]
case Type _ => lang::java::m3::AST::float()
case Modifier _ => lang::java::m3::AST::\public()
case \method(_, _, a, b) => \method(lang::java::m3::AST::float(), "method", a, b)
case \method(_, _, a, b, c) => \method(lang::java::m3::AST::float(), "method", a, b, c)
case \parameter(a, _, b) => \parameter(a, "parameter", b)
case \vararg(a, _) => \vararg(a, "vararg") 
case \annotationTypeMember(a, _) => \annotationTypeMember(a, "annotationTypeMember")
case \annotationTypeMember(a, _, b) => \annotationTypeMember(a, "annotationTypeMember", b)
case \typeParameter(_, a) => \typeParameter("typeParameter", a)
case \constructor(_, a, b, c) => \constructor("constructor", a, b, c)
case \interface(_, a, b, c) => \interface("interface", a, b, c)
case \class(_, a, b, c) => \class("class", a, b, c)
case \enumConstant(_, a) => \enumConstant("enumConstant", a) 
case \enumConstant(_, a, b) => \enumConstant("enumConstant", a, b)
case \methodCall(a, _, b) => \methodCall(a, "methodCall", b)
case \methodCall(a, b, _, c) => \methodCall(a, b, "methodCall", c)
case \simpleName(_) => \simpleName("simpleName")
case \number(_) => \number("125681651")
case \variable(_, a) => \variable("variable", a) 
case \variable(_, a, b) => \variable("variable", a, b) 
case \booleanLiteral(_) => \booleanLiteral(true)
case \stringLiteral(_) => \stringLiteral("stringLiteral")
case \characterLiteral(_) => \characterLiteral("a")
\end{lstlisting}

\subsection{The main algorithm}

Here we provide a textual representation of our main algorithm. For further information please have a look into the source file \texttt{DuplicationsAnalyzer.rsc}.

\begin{lstlisting}
Build the AST of the project.

For all nodes in AST 
- If size of node > threshold
- Clean node for type 1 detection.
- Clean node for type 2 detection.
- Collect node in map with cleaned node as key, 
  relation of original node and location as value

For all keys in Map build a set of clone classes
- Collect all values from the map for current key
- If size of collected values > 1 Then add values 
  as a new clone class to set

Filter subclone classes
- For all previously detected clone classes
- If another clone class exists for which all locations 
  include the locations of the current one Then
-
Else
Add to new Set

For all filtered clone classes
- Collect them in output format
- Collect locations
- Determine line statistics
- Determine clone type

\end{lstlisting}

\section{Main program validity}
\todo {Write about automatic tests - describe what the tests do (be convincing)}

All tests are in separate files that extend their original rascal module:

\begin{itemize}

\item
  DuplicationsAnalyzerTests
\item
  RaterTests
\item
  UtilsTests
\item
  VolumeAnalyzerTests
\end{itemize}

To run the tests, import all the modules above and execute :test in the
rascal console. The \texttt{projectLocation} in
\texttt{Configuration.rsc} has to be set to the projects location in
your eclipse!


\section{The tool}
\todo{
\begin{itemize}
\item{General description and purpose, used solutions (webserver, REST api, ReactJS app, d3 graphs, etc)}
\item{The 3 main requirements (your tool satises from the perspective of a maintainer) [ref to storey1999cognitive]:
  \begin{enumerate}
    \item{Get a comprehensible overview (of code quality and duplications) 
      \begin{itemize}
        \item{Readable table}
        \item{SIG maintanability index}
      \end{itemize}
      }
    \item{Get a deep insight into the clones 
      \begin{itemize}
        \item{navigate easily through them}
        \item{provide and extended search function (easy to use = we reduce eort)}
      \end{itemize}
     }
    \item{See how the clones spread over my project (=Improve comprehension ) 
      \begin{itemize}
        \item{provide insightful visualization = Provide eective presentation styles (graph)}
        \item{show how the les containing clones relate to each other (=indicate options for further exploration)}
      \end{itemize}
      }
  \end{enumerate}
}
\item{Implementation choices}
\item{The visualisation (constellation) - how does it help a maintainer or a developer?}
\end{itemize}
}


\section{Tool manual}
\todo {
	\begin{itemize}
		\item{How to run}
		\item{How to use}
		\item{Where is the Rascal project}
		\item{Where is the original visualisation project }
	\end{itemize}
}

To use the tool we provide the source code as a eclipse project

\subsection{How to run}

In order to run the program, please follow the steps:

\begin{enumerate}
\item
  Please import the project into your eclipse with a working rascal
  installation.
\item
  Open \texttt{Configuration.rsc} and adjust the location of the
  \texttt{projectLocation} to match the path of the project to your
  eclise
\item
  Do the same for the \texttt{smallSqlProject} and \texttt{hqSqlProject}
\item
  Start a rascal console and import the \texttt{Main} module
\item
  run \texttt{startServe();}
\item
  open a browser and point it towards \texttt{http://localhost:5433} or
  to the location of \texttt{serveAddress} in case you changed it
\end{enumerate}


\section{Summary}
\todo {
	\begin{itemize}
		\item{Sum things up}
		\item{Write how the tool performs on hsqlsb,}
		\item{Write how it can be improved}
	\end{itemize}
}



%-------------------------------------------------------------------------------
%	REFERENTIES
%-------------------------------------------------------------------------------

\printbibliography

%-------------------------------------------------------------------------------
%	BIJLAGEN EN EINDE
%-------------------------------------------------------------------------------

%\section{Bijlage A}
%\section{Bijlage B}
%\section{Bijlage C}
\end{document}
